<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='an algorithm for the generalised version of the Mastermind game'>

<meta property='og:title' content='Mastermind | Ádám Urbán'>
<meta property='og:description' content='an algorithm for the generalised version of the Mastermind game'>
<meta property='og:url' content='http://adamurban.net/mastermind/'>
<meta property='og:site_name' content='Ádám Urbán'>
<meta property='og:type' content='article'><meta property='article:section' content='Page'><meta property='article:published_time' content='2018-03-17T16:23:24Z'/><meta property='article:modified_time' content='2018-03-17T16:23:24Z'/><meta property='fb:admins' content='adamurban1998'><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.36" />

  <title>Mastermind | Ádám Urbán</title>
  <link rel='canonical' href='http://adamurban.net/mastermind/'>
  
  
  <link rel='icon' href='/images/logo.png'>
<link rel='stylesheet' href='/assets/css/main.9efb8af6.css'><link rel='stylesheet' href='/css/custom.css'>
</head>


<body class='page type-page has-sidebar sidebar-sticky'>

  <div class='site'>

    <a class='screen-reader-text' href='#main-menu'>Skip to Main Menu</a>

<div id='sidebar' class='sidebar'>
  <div class='container'><section class='widget widget-about sep-after'>
  <header>
    
    <div class='logo'>
      <a href='/'>
        <img src='/images/adam_round.png'>
      </a>
    </div>
    
    <h2 class='title site-title '>
    Ádám Urbán
    </h2>
    <div class='desc'>
    Student @ Imperial College
    </div>
  </header>

</section>
<section class='widget widget-social_menu sep-after'><nav aria-label='Social Menu'>
    <ul><li>
        <a href='https://github.com/adamurban98' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Open Github account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
  
</svg>
</a>
      </li><li>
        <a href='https://facebook.com/adamurban1998' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Open Facebook account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
  
</svg>
</a>
      </li><li>
        <a href='mailto:adamurban98@gmail.com' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Contact via Email</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
  <polyline points="22,6 12,13 2,6"/>
  
</svg>
</a>
      </li><li>
        <a href='https://linkedin.com/in/adamurban98' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Open Linkedin account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"/>
  <rect x="2" y="9" width="4" height="12"/>
  <circle cx="4" cy="4" r="2"/>
  
</svg>
</a>
      </li></ul>
  </nav>
</section>
</div>
</div>

    <div class='main'>

      <nav id='main-menu' class='main-menu' aria-label='Main Menu'>
  <div class='container'>
    <a class='screen-reader-text' href='#content'>Skip to Content</a>

<button id='sidebar-toggler' class='hamburger hamburger--arrow sidebar-toggler' type='button' aria-controls='sidebar' aria-expanded='false'>
  <span class='screen-reader-text'>Toggle Sidebar</span>
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    <ul><li class='item'>
        <a href='/'>Home</a>
      </li><li class='item'>
        <a href='/rep/'>Representation</a>
      </li><li class='item'>
        <a href='/cv/'>cv</a>
      </li><li class='item'>
        <a href='https://www.linkedin.com/in/adamurban98/'>Linked-In</a>
      </li><li class='item'>
        <a href='/contact/'>Contact</a>
      </li></ul>
  </div>
</nav>


      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>Ádám Urbán</p><p class='desc site-desc'>Student @ Imperial College</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Mastermind</h1>
      
<p class='desc'>an algorithm for the generalised version of the Mastermind game</p>


    </div>
    

  </div>
</header>

  
  
<details class='container entry-toc'>
  <summary class='title'>
    <span>Table of Contents</span>
  </summary>
  <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#technical-notes">Technical notes</a></li>
<li><a href="#mastermind-rules">Mastermind rules</a>
<ul>
<li><a href="#formal-definitions-of-w-and-b">Formal definitions of $w$ and $b$</a></li>
</ul></li>
<li><a href="#the-code-maker">The code maker</a>
<ul>
<li><a href="#calculation-of-b-black-pegs">Calculation of $b$ - black pegs</a></li>
<li><a href="#calculation-of-w-white-pegs">Calculation of $w$ - white pegs</a></li>
<li><a href="#overall-complexity-of-code-maker-s-algorithms">Overall complexity of code maker&rsquo;s algorithms</a></li>
</ul></li>
<li><a href="#the-code-solver">The code solver</a>
<ul>
<li><a href="#disambiguation-of-terms">Disambiguation of terms</a></li>
<li><a href="#review-of-strategies">Review of strategies</a></li>
<li><a href="#approach-for-n-leq-10">Approach for $n \leq 10$</a></li>
<li><a href="#approach-for-n-10">Approach for $n&gt;10$</a>
<ul>
<li><a href="#stage-1-monochromatic-queries">Stage 1: Monochromatic queries</a>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#complexity">Complexity</a></li>
</ul></li>
<li><a href="#stage-2-finding-a-dummy">Stage 2: Finding a dummy</a>
<ul>
<li><a href="#example-1">Example</a></li>
<li><a href="#complexity-1">Complexity</a></li>
</ul></li>
<li><a href="#stage-3-binary-search">Stage 3: Binary search</a>
<ul>
<li><a href="#interval-tree">Interval tree</a></li>
<li><a href="#getting-the-next-query-range">Getting the next query range</a></li>
<li><a href="#teaching-the-results">Teaching the results</a></li>
<li><a href="#complexity-2">Complexity</a></li>
</ul></li>
<li><a href="#optimizations-and-performace">Optimizations and performace</a>
<ul>
<li><a href="#comparing-with-other-algorithms">Comparing with other algorithms</a></li>
<li><a href="#optimizations">Optimizations</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
</details>


  <div class='container entry-content'>
  

<h2 id="technical-notes">Technical notes</h2>

<p>This document is intended as a suplementary description of my solution to the 3rd assignment of module Introduction to Computing at Imperial College London.</p>

<p>When dealing with code, <code>C++</code> is assumed and used, unless stated othwerwise. <code>C++11</code> features are used.</p>

<h2 id="mastermind-rules">Mastermind rules</h2>

<p>In the beginning the <em>code maker</em> generates a valid code, which will be refered to as <em>codeword</em>.
A valid code is any arbitrary sequence of $n$ non-negative integers - <em>colours</em> -, each from the range $[0,k)$. Since in the original version of Mastermind the codes consist of &ldquo;colours&rdquo; instead of non-negative integers, in this document we will use the term <em>colour</em> as a shorthand in a similar meaning. Also, in the original version the parameters are kept constant as follows: $n=4, k=6$, this document, however, considers the general case.</p>

<p>Following this, the code solver can <em>query</em> a valid code of his choice and is given a response of two integers $b$ and $w$. These correspond to the black and white pegs in the original game.</p>

<p><strong>The goal</strong> if the game is to guess the <em>codeword</em> in the least possible number of queries.</p>

<h3 id="formal-definitions-of-w-and-b">Formal definitions of $w$ and $b$</h3>

<p>$b$ is always equal to the number of correctly guessed <em>colours</em> (<em>i.e.</em> correct <em>colours</em> on the correct position). Formally: Let the code maker&rsquo;s <em>codeword</em> be $c_1 c_2 c_3 &hellip; c_{n-1}$ and the attempted code $a_1 a_2 a_3 &hellip; a_{n-1}$. $b$ equals to the number of indeces $i$ such that $c_i = a_i$.</p>

<p>Commonly, $w$ is defined as the number of incorrectly positioned colours in an <em>attempt</em>. Formally: Let $C_i$ and $A_i$ be the number of occurences if <em>colour</em> $i$ in the secret code and the attempted code, respectively. Then:</p>

<p>$$ w = \biggl( {\sum_{i=0}^{k-1} min(C_i, A_i)} \biggr)  - b $$</p>

<h2 id="the-code-maker">The code maker</h2>

<p>Let us begin with the code solver as this player needs a significantly simpler algorithm.</p>

<h3 id="calculation-of-b-black-pegs">Calculation of $b$ - black pegs</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">black</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span> code, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> attempt){
	<span style="color:#66d9ef">int</span> black <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n, i<span style="color:#f92672">++</span>){  	<span style="color:#75715e">// n - length of codeword
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(code[i] <span style="color:#f92672">==</span> attempt[i]){
			black<span style="color:#f92672">++</span>;
		}
	}
	<span style="color:#66d9ef">return</span> black;
}</code></pre></div>
<ul>
<li>Time complexity:  $O(n)$</li>
<li>Space complexity: $O(1)$</li>
</ul>

<h3 id="calculation-of-w-white-pegs">Calculation of $w$ - white pegs</h3>

<p>The easiest and most efficient way to compute $w$ is to calculate an array <code>color_count_query[i]</code> of integers conataining  the number of occurences of <em>colour</em> $i$ in the <em>query</em> and maintain a similar array <code>color_count_codeword[i]</code> for the <em>codeword</em>. Afterwards we can easily implement the definition of $w$.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> black <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> white <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&gt;</span> color_count_query <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(k, <span style="color:#ae81ff">0</span>)
<span style="color:#75715e">// color_count_codeword already given
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n, i<span style="color:#f92672">++</span>){ <span style="color:#75715e">// n - length of codeword
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(codeword[i] <span style="color:#f92672">==</span> query[i]){
		black<span style="color:#f92672">++</span>;
	}
	color_count_query[ query[i] ]<span style="color:#f92672">++</span>;
}
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k, i<span style="color:#f92672">++</span>){ <span style="color:#75715e">//k - number of colours
</span><span style="color:#75715e"></span>	white <span style="color:#f92672">+=</span> min(color_count_query[i],color_count_codeword[i]); <span style="color:#75715e">// either use std::min() or own implementation
</span><span style="color:#75715e"></span>}
white <span style="color:#f92672">-=</span> black;

<span style="color:#f92672">//</span><span style="color:#66d9ef">return</span> black and white </code></pre></div>
<ul>
<li>Time complexity: $O(n+k)$</li>
<li>Space complexity: $O(k)$</li>
</ul>

<h3 id="overall-complexity-of-code-maker-s-algorithms">Overall complexity of code maker&rsquo;s algorithms</h3>

<p>The complexity of the two algorithms combined is</p>

<ul>
<li>Time complexity: $O(n+k)$<br /></li>
<li>Space complexity: $O(k)$<br /></li>
</ul>

<p>One can hardly optimize these complexities. Also, it is not a goal of my solution to do so, as the code maker&rsquo;s response is considered to be a rather externally given mechanism. It certainly could be optimised by omitting white pegs - as we will se later -, but again, this would mean a interference with the external mechanism and the rules of the game.</p>

<h2 id="the-code-solver">The code solver</h2>

<h3 id="disambiguation-of-terms">Disambiguation of terms</h3>

<p>In the rest of this document we will speak in terms of number of queries and <em>query complexity</em> so to avoid dealing with technicalities of the code maker&rsquo;s algorithm.</p>

<p>The time complexity of the code solver&rsquo;s algorithm can be of much bigger interest as the code makers&rsquo;s algorithm , albeit we will omit it for certain sections too or will deal with it separately.</p>

<h3 id="review-of-strategies">Review of strategies</h3>

<h3 id="approach-for-n-leq-10">Approach for $n \leq 10$</h3>

<h3 id="approach-for-n-10">Approach for $n&gt;10$</h3>

<h4 id="stage-1-monochromatic-queries">Stage 1: Monochromatic queries</h4>

<p>The first stage is very simple. The code solver queries $i, i \epsilon [0,k)$ (<em>monochromatic</em>) queries each consisting only of colour $i$ .</p>

<h5 id="example">Example</h5>

<p>Let $n=4, k=6$ and let the secret <em>codeword</em> be:</p>

<pre><code>1 4 4 2
</code></pre>

<p>Stage 1 would look like this:</p>

<pre><code>0 0 0 0  Black: 0, White: 0 	// colour 0  is present 0 times
1 1 1 1  Black: 1, White: 0 	// colour 1  is present 1 times
2 2 2 2  Black: 1, White: 0 	// colour 2  is present 1 times
3 3 3 3  Black: 0, White: 0 	// colour 3  is present 0 times
4 4 4 4  Black: 2, White: 0 	// colour 4  is present 2 times
5 5 5 5  Black: 0, White: 0 	// colour 5  is present 0 times
</code></pre>

<p>From these information we can set up an array of frequencies of colours in the solution which we will utilise in later steps.</p>

<h5 id="complexity">Complexity</h5>

<ul>
<li>Query complexity: $O(k)$</li>
<li>Complexity of generating each query:

<ul>
<li>Time complexity: $O(n)$</li>
<li>Space complexity: $O(n)$</li>
</ul></li>
</ul>

<h4 id="stage-2-finding-a-dummy">Stage 2: Finding a dummy</h4>

<p>We will consider a dummy code any code that gives a response of zero black pegs. A trivial dummy might be a <em>monochromatic</em> sequence tried in stage 1. Nothing guarntees that such a monochromatic query will exist, nevertheless this shortcut is implemented, albeit just as an optimisation.</p>

<p>To guaranteedly find a dummy query we test all queries with one <code>1</code> on position $i, i \epsilon [0,n) $, and the remaining  $n-1$ slots filled with <code>0</code>-s. Let $C_0$ be the number of <code>0</code>-s in the <em>codeword</em> and $c_i$ the i-th <em>colour</em> of the <em>codeword</em>. Than for each value of $i$ three cases are possible based on the number of black pegs $b_i$ received as answer to such a query:</p>

<ol>
<li>$C_0 &lt; b_i \implies c_i = 1$</li>
<li>$C_0 = b_i  \implies c_i \neq 1, c_i \neq 0$</li>
<li>$C_0 &gt; b_i \implies c_i = 0$</li>
</ol>

<h5 id="example-1">Example</h5>

<p>Let $n=4, k=6$ and let the secret <em>codeword</em> be:</p>

<pre><code>3 1 0 5
</code></pre>

<p>In stage 1 we already tested <code>0 0 0 0</code> with result <code>Black: 1, White: 0</code>.</p>

<p>The queries stage 2 would be:</p>

<pre><code>1 0 0 0  Black: 1, White: 1 	// position 1 is neither 0 nor 1
0 1 0 0  Black: 2, White: 0 	// position 2 is 1
0 0 1 0  Black: 0, White: 2 	// position 3 is 0
0 0 0 1  Black: 1, White: 1 	// position 4 is neither 0 nor 0

The codeword is: X 1 0 X 	// X = unknown
A dummy code is: 0 0 1 0
</code></pre>

<h5 id="complexity-1">Complexity</h5>

<ul>
<li>Query complexity: $O(n)$</li>
<li>Complexity of generating each query:

<ul>
<li>Time complexity: $O(n)$</li>
<li>Space complexity: $O(n)$</li>
</ul></li>
</ul>

<h4 id="stage-3-binary-search">Stage 3: Binary search</h4>

<p>The dummy sequence is a profoundly useful tool. It enables us to query the number of occurences of colour <code>C</code> under a arbitrary range or range of colours. We can do this by submitting the following query:</p>

<pre><code>D0 D1 C C C D5 D6 D7
</code></pre>

<p>where <code>D</code>-s are the members of the dummy code.</p>

<h5 id="interval-tree">Interval tree</h5>

<p>Note that the each node has a pointer to its parent, this will be necessary when traversing the tree upwards. This stage consist of $i, i \epsilon [0,k)$ substages. In the beginning of each substage the remaining field of <em>all</em> intervals is set to the nuber of occurences of the colour $i$ in the original <em>codeword</em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> interval_node{
	<span style="color:#66d9ef">int</span> min;				<span style="color:#75715e">// values from (including)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> max;				<span style="color:#75715e">// values upto (including)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> remaining;			<span style="color:#75715e">// count of potentially 
</span><span style="color:#75715e"></span>							<span style="color:#75715e">// present numbers under this interval
</span><span style="color:#75715e"></span>	interval_node <span style="color:#f92672">*</span> left;	<span style="color:#75715e">// interval [min,floor((min+max)/2)]
</span><span style="color:#75715e"></span>	interval_node <span style="color:#f92672">*</span> right;	<span style="color:#75715e">// interval [ceil((min+max)/2), max]
</span><span style="color:#75715e"></span>	interval_node <span style="color:#f92672">*</span> parent;	<span style="color:#75715e">// pointer to parent, NULL for root
</span><span style="color:#75715e"></span>};</code></pre></div>
<p>This data structure satisfies the following criteria:</p>

<ul>
<li>Binary tree</li>
<li>Search tree (ordered)</li>
<li>Interval (segment) tree</li>
</ul>

<p>The following conditions will be always true for the interval tree:</p>

<ul>
<li>in the beginning each interval has a remaining equal to the number of occurences of the given <em>colour</em>.</li>
<li>an intervall shall be called <em>accesible</em> if all its ancestors have <code>remaining</code> $&gt;0$.</li>
<li>a interval shall be called <em>live</em> if is <em>accesible</em> and has <code>remaining</code> $&gt;0$. Otherwise is <em>dead</em>.</li>
<li>if</li>
</ul>

<h5 id="getting-the-next-query-range">Getting the next query range</h5>

<p>The next queried interval is found by recoursively traversing the <em>live</em> interval nodes of the interval tree from its root. We should querry the first interval that satisfies the following condition:</p>

<ul>
<li>is <em>live</em></li>

<li><p>its sibling has not been querried</p>

<h5 id="teaching-the-results">Teaching the results</h5></li>
</ul>

<h5 id="complexity-2">Complexity</h5>

<ul>
<li>Query complexity: $O(n \log_2n)$</li>
<li>Time complexity of generating each query: $O(\log_2n)$</li>
<li>Time complexity of generating the interval tree for each colour $O(n)$</li>
<li>Overall time complexity: $O(k * n + n^2 \log_2n)$</li>
</ul>

<h4 id="optimizations-and-performace">Optimizations and performace</h4>

<p>A summary of question complexity of each stages:</p>

<ul>
<li>Stage 1: $O(k)$</li>
<li>Stage 2: $O(n)$</li>
<li>Stage 3: $O(n \log_2n)$</li>
</ul>

<p>The <em><strong>overall query complexity</strong></em> reduces to:</p>

<p>$$O(k+n \log_2n)$$</p>

<p>With a <em><strong>total running time</strong></em> complexity:</p>

<p>$$O(k*n + n^2 \log_2n)$$</p>

<p>As we can see a $k &gt;&gt; n$ would only have effect by prolonging stage 1. Also, research literature on this topic devotes attention mainly to the &ldquo;<em>prominent</em>&rdquo; case when $k \approx n$ as otherwise the game has lots of unused colours, or on the contrary many repetitive colour. The latter results in a possible optimization discussed below. For these reasons $k=n$ is assumed for comparing the complexities of my algorithm with the algorithms of research on the internet.</p>

<h5 id="comparing-with-other-algorithms">Comparing with other algorithms</h5>

<p>This algorithm features a rather modest space complexity ( $O(n+k)$ since we only need to maintain a $n$ sized binary interval tree and a constant number of arrays of size $n$ and $k$), compared to the algorithms in the recent research papers, which maintain a set of <em>colours</em> of size $k$ for each position ($O(k*n)$)!</p>

<p>In my personal opinion the achieved <em>time</em> and <em>query</em> complexity can be seen as a good result given the lightweight nature of this approach. On the other hand the <em>query complexity</em> of these is silghtly better: $O(n \log_2 \log_2 n)$, compared to mine $O(n \log_2 n)$.</p>

<h5 id="optimizations">Optimizations</h5>

<blockquote>
<p>“Premature optimization is the root of all evil”
&mdash; D. Knuth</p>
</blockquote>

<p>A <strong>significant  <em>query</em> complexity optimization</strong> could be achieved by restricting the binary search to positions which have not been determined yet. This would however require a very much different interval tree, and possibly its re-building for each <em>colour</em> for each colour.  Therefore this optimization is not implemented.</p>

<p>The following two <strong><em>query</em> complexity optimizations</strong> were implemented because of their very simple implementation:</p>

<ol>
<li>Finding all <code>0</code>-s and <code>1</code>-s during stage 2</li>
<li>Skipping stage 2 if a <em>monochromatic dummmy</em> is found in stage 1. (common for $n \lessapprox k$)</li>
</ol>

<p>One <strong><em>time</em> complexity optimization</strong> is implemented:
Omitting printouts of the queried array ($O(n)$ time complexity). This significantly boosted the programs speed.</p>

<p><img src="/images/mastermind/100x100.gif" alt="100x100" /></p>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script> 

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$']],        // also, but now disabled: ['\\(','\\)']
    displayMath: [['$$','$$']],     // also, but noe disabled: ['\[','\]']
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    // Fix <code> tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script> 

</div>

  

</article>



      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'>
          <section class='widget widget-social_menu sep-after'><nav aria-label='Social Menu'>
    <ul><li>
        <a href='https://github.com/adamurban98' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Open Github account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
  
</svg>
</a>
      </li><li>
        <a href='https://facebook.com/adamurban1998' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Open Facebook account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
  
</svg>
</a>
      </li><li>
        <a href='mailto:adamurban98@gmail.com' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Contact via Email</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
  <polyline points="22,6 12,13 2,6"/>
  
</svg>
</a>
      </li><li>
        <a href='https://linkedin.com/in/adamurban98' target='_blank' rel='noopener'>
          <span class='screen-reader-text'>Open Linkedin account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"/>
  <rect x="2" y="9" width="4" height="12"/>
  <circle cx="4" cy="4" r="2"/>
  
</svg>
</a>
      </li></ul>
  </nav>
</section>

          <div class='copyright'>
  <p> &copy; 2018 Ádám Urbán </p>
</div>

        </div>
      </footer>

    </div>
  </div><div class='sidebar-overlay'></div><script src='/assets/js/main.89545a27.js'></script><script src='/js/custom.js'></script></body>

</html>

